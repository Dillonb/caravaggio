
//CAUTION: The content of this file is automatically generated by Emacs orgmode
//from the file caravaggio.org that should either be in this, or the parent
//directory. Consequently, any modifications made to this file will likely be
//ephemeral. Please edit caravaggio.org instead.
////////////////////////////////////////////////////////////////////////////////
//
// caravaggio.cpp
//
////////////////////////////////////////////////////////////////////////////////
//
//================================================================================
// This file is part of project caravaggio, a simple demonstration of the OpenGL
// API, that generates several polyhedra, each decorated with a texture map
// that is derived from an input digital image.
//
// caravaggio is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// caravaggio is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with union-find.org.  If not, see <http://www.gnu.org/licenses/>.
//
// Copyright (C) 2014, 2015 Robert R. Snapp.
//================================================================================
// This file was automatically generated using an org-babel tangle operation with
// the file caravaggio.org. Thus, the latter file should be edited instead of
// this file.
//================================================================================
//
//
// Standard C++ libraries
#include <algorithm>   // for max and min
#include <iostream>
#include <stdexcept>
#include <cmath>
#include <climits>
#include <ctime>
#include <sstream>
#include <fstream>
#include <string>
#include <cstdlib>                       // for rand(), srand()
#include <random>                        // for the Mersenne Twister using in caravaggioImageFrame.
#include <vector>
#include <cstring>

// Graphics libraries that extend OpenGL
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

// FreeImage headers, for digital image format support.
#include <FreeImage.h>

// Headers for our models
#include "sphere.h"
#include "cylinder.h"
#include "cube.h"

std::vector<Sphere> SphereVector;
std::vector<Cylinder> CylinderVector;
std::vector<Cube> CubeVector;

glm::vec3 TheAmbientIntensity;
glm::vec3 TheLightIntensity;
glm::vec3 TheLightPosition;

GLFWwindow* gWindow = NULL;               // pointer to the graphics window goverened by the OS
const glm::vec2 CANVAS(800, 800);         // Our window and viewport dimensions.

const size_t MAX_FILE_MATCH_ATTEMPTS = 1000;

GLint SL_ModelViewTransformation;
GLint SL_NormalVectorTransformation;
GLint SL_ModelViewPerspectiveTransformation;
GLint SL_AmbientIntensity;
GLint SL_LightIntensity;
GLint SL_LightPosition;
GLint SL_EyeDirection;
double Theta = M_PI/90.0;
double Phi   = 0.0;
double Rho   = 8.0;

GLuint loadAndCompileShader(GLenum shaderType, const std::string& path) {
   std::ifstream f;
   f.open(path.c_str(), std::ios::in | std::ios::binary);
   if (!f.is_open()) {
      throw std::runtime_error(std::string("Can't open shader file ") + path);
   }

// read the shader program from the file into the buffer
std::stringstream buffer;
buffer << f.rdbuf();

GLuint shader = glCreateShader(shaderType);
if (! shader) {
   throw std::runtime_error(std::string("Can't create shader for file ") + path);
}

// tricky conversion from a stringstream buffer to a C (null terminated) string.
const std::string& bufferAsString = buffer.str();
const GLchar* shaderCode = bufferAsString.c_str();
const GLchar* codeArray[] = { shaderCode };
//GLint size = strlen(shaderCode);
glShaderSource(shader, 1, codeArray, NULL);
glCompileShader(shader);

   GLint status;
   glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
   if (! status) {
      std::cerr << "Compilation error in shader file " << path << std::endl;
      GLint logLen;
      glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logLen);
      if (logLen > 0) {
         char *log = new char[logLen];
         GLsizei written;
         glGetShaderInfoLog(shader, logLen, &written, log);
         std::cerr << "Shader log: " << std::endl;
         std::cerr << log << std::endl;
         delete [] log;
      }
      throw std::runtime_error(
         std::string("Can't compile the shader defined in file ") + path);
   }
   return shader;
}

GLuint createVertexFragmentProgram(const std::string& vertex_shader_path,
   const std::string& fragment_shader_path) {
      GLuint vertexShader   = loadAndCompileShader(GL_VERTEX_SHADER,   vertex_shader_path);
      GLuint fragmentShader = loadAndCompileShader(GL_FRAGMENT_SHADER, fragment_shader_path);

GLuint program = glCreateProgram();
if (! program) {
   throw std::runtime_error("Can't create GLSL program.");
}

glAttachShader(program, vertexShader);
glAttachShader(program, fragmentShader);
glLinkProgram(program);

   GLint status;
   glGetProgramiv(program, GL_LINK_STATUS, &status);
   if (! status) {
      std::cerr << "Linking error in shader program!" << std::endl;
      GLint logLen;
      glGetProgramiv(program, GL_INFO_LOG_LENGTH, &logLen);
      if (logLen > 0) {
         char *log = new char[logLen];
         GLsizei written;
         glGetProgramInfoLog(program, logLen, &written, log);
         std::cerr << "Shader log: " << std::endl;
         std::cerr << log << std::endl;
         delete [] log;
      }
      throw std::runtime_error("Can't link shader program.");
   }
   return program;
}

std::string getUnusedFileName(const std::string &prefix, const std::string &ext) {
   std::string imageFileName("");  // initial value is returned in search fails.

   // load the current date and time in theTime.
   time_t theTime;
   time(&theTime);

   // convert the date time into the current locale.
   struct tm *theTimeInfo;
   theTimeInfo = localtime(&theTime);

// represent the date and time in the format "150117184509" for 2015 January 17,
// 18 hours, 45 minutes, 09 seconds.
const int TIME_STRING_SIZE = 16;  // must be at least 13.
char timeString[TIME_STRING_SIZE];
strftime(timeString, TIME_STRING_SIZE, "%y%m%d%H%M%S", theTimeInfo);

std::stringstream filename;
std::ifstream fs;
int index =0;

// find a new filename of the form <filenameprefix>_<timeString>_<index>.<ext>, where
// <index> is incremented as needed.
do {
   // reset the stringstream filename
   filename.str(std::string());      // clear the buffer content
   filename.clear();                 // reset the state flags

   // propose an available (unused) filename.
   filename << prefix << "_" << timeString << "_" << index++ << ext;

   // Ensure the ifstream fs is closed.
   if (fs.is_open()) fs.close();

   // If file does not exist, it can't be opened in input mode.
   fs.open(filename.str(), std::ios_base::in);
} while (fs.is_open() && index < MAX_FILE_MATCH_ATTEMPTS);

   // Test to see if a unique name was actually found.
   if (fs.is_open() && index >= MAX_FILE_MATCH_ATTEMPTS) {
      fs.close();  // failure: there are too many files with the same time stamp.
   } else {       // N.B. fs must be closed on this branch, right?
      imageFileName = filename.str();  // success!
   }
   return imageFileName;
}

void exportImageAsPNG(GLubyte* image, GLuint width, GLuint height, const std::string& filename_prefix) {
    // The following variables are introduced to clarify the call signature of
    // FreeImage_ConvertFromRawBits, which will convert the GLubyte pixel buffer
    // into a FreeImage buffer.
    const unsigned int red_mask             = 0xFF0000;
    const unsigned int green_mask           = 0x00FF00;
    const unsigned int blue_mask            = 0x0000FF;
    const unsigned int bits_per_pixel       = 24;
    const bool top_left_pixel_appears_first = false;

    unsigned int bytes_per_row = 3 * width;

    FIBITMAP* fi_image = FreeImage_ConvertFromRawBits(image, width, height, bytes_per_row,
                                                   bits_per_pixel, red_mask, green_mask,
                                                   blue_mask, top_left_pixel_appears_first);

std::string imagefilename = getUnusedFileName(filename_prefix, std::string(".png"));
if (imagefilename.length() == 0) {
    throw std::runtime_error("Can't find an available png file name.");
}

FreeImage_Save(FIF_PNG, fi_image, imagefilename.c_str(), 0);  // Save fi_image as a PNG file.

    // Free allocated memory
    FreeImage_Unload(fi_image);
    return;
}

void exportWindowAsPNG(GLFWwindow* window, const std::string &prefix) {
   // Recover window dimensions from glfw
   int width;
   int height;
   glfwGetFramebufferSize(window, &width, &height);

// allocate a buffer to store all of the pixels in the frame buffer.
GLubyte* pixels = new GLubyte [width * height * sizeof(GLubyte)* 3];
if (! pixels) {
   throw std::runtime_error(std::string("Can't allocate pixel array for image of size ")
      + std::to_string(width) + std::string(" by ") + std::to_string(height)
      + std::string(" pixels."));
}

glPixelStorei(GL_PACK_ALIGNMENT, 1); // Align data by bytes so the framebuffer data will fit.
glReadBuffer(GL_FRONT);              // The front color buffer is the visible one.
glReadPixels(0, 0, width, height, GL_BGR, GL_UNSIGNED_BYTE, pixels);

exportImageAsPNG(pixels, width, height, prefix);

   delete [] pixels;
   return;
}


void init() {

   Sphere::initialize_class();
   Cylinder::initialize_class();
   Cube::initialize_class();

   /*
    for (int i = 0; i < 3; i++) {
        GLfloat tx = 2.0f*(i - 1);
        for(int j = 0; j < 3; j++) {
            GLfloat ty = 2.0*(j - 1);
            GLfloat tz = 0.0f;
            GLfloat rhoRed = 0.9 - i*0.1;
            GLfloat rhoGreen = 0.9 - j*0.1;
            GLfloat rhoBlue  = 0.9 - (i + j)*0.1;
            Sphere *s = new Sphere(glm::vec3(tx, ty, tz), 0.5f);
            s->set_ambient_rho(glm::vec3(rhoRed, rhoGreen, rhoBlue));
            s->set_diffuse_rho(glm::vec3(rhoRed, rhoGreen, rhoBlue));
            s->set_specular_rho(glm::vec3(rhoRed, rhoGreen, rhoBlue));
            s->set_shininess(30.0f);
            SphereVector.push_back(*s);
            delete s;
        }
    }
    */




   GLfloat rhoRed;
   GLfloat rhoGreen;
   GLfloat rhoBlue;


   Cube *c = new Cube();
   rhoRed = 0;
   rhoGreen = 0;
   rhoBlue = 0;
   c->set_ambient_rho(glm::vec3(rhoRed, rhoGreen, rhoBlue));
   c->set_diffuse_rho(glm::vec3(rhoRed, rhoGreen, rhoBlue));
   c->set_specular_rho(glm::vec3(rhoRed, rhoGreen, rhoBlue));
   c->set_shininess(3000.0f);
   CubeVector.push_back(*c);
   delete c;

   Sphere *s = new Sphere();
   rhoRed = 0;
   rhoGreen = 0;
   rhoBlue = 0;
   s->set_ambient_rho(glm::vec3(rhoRed, rhoGreen, rhoBlue));
   s->set_diffuse_rho(glm::vec3(rhoRed, rhoGreen, rhoBlue));
   s->set_specular_rho(glm::vec3(rhoRed, rhoGreen, rhoBlue));
   s->set_shininess(3000.0f);
   SphereVector.push_back(*s);
   delete s;

   Cylinder *cy = new Cylinder();
   rhoRed = .7;
   rhoGreen = .7;
   rhoBlue = .7;
   cy->set_ambient_rho(glm::vec3(rhoRed, rhoGreen, rhoBlue));
   cy->set_diffuse_rho(glm::vec3(rhoRed, rhoGreen, rhoBlue));
   cy->set_specular_rho(glm::vec3(rhoRed, rhoGreen, rhoBlue));
   cy->set_shininess(30.0f);
   CylinderVector.push_back(*cy);
   delete cy;




    TheAmbientIntensity = glm::vec3(0.1f, 0.1f, 0.08f);
    TheLightIntensity   = glm::vec3(1.0f, 1.0f, 0.8f);  // a yellow tint.
    TheLightPosition    = glm::vec3(0.0f, 0.0f, 10.0f);

    GLuint shader_program = createVertexFragmentProgram(std::string("phong.vert"),
            std::string("phong.frag"));
    glUseProgram(shader_program);

    Sphere::set_ambient_rho_SL(glGetUniformLocation(shader_program, "AmbientRho"));
    Sphere::set_diffuse_rho_SL(glGetUniformLocation(shader_program, "DiffuseRho"));
    Sphere::set_specular_rho_SL(glGetUniformLocation(shader_program, "SpecularRho"));
    Sphere::set_shininess_SL(glGetUniformLocation(shader_program, "Shininess"));

    Cylinder::set_ambient_rho_SL(glGetUniformLocation(shader_program, "AmbientRho"));
    Cylinder::set_diffuse_rho_SL(glGetUniformLocation(shader_program, "DiffuseRho"));
    Cylinder::set_specular_rho_SL(glGetUniformLocation(shader_program, "SpecularRho"));
    Cylinder::set_shininess_SL(glGetUniformLocation(shader_program, "Shininess"));

    SL_ModelViewTransformation = glGetUniformLocation(shader_program, "ModelViewTransformation");
    SL_NormalVectorTransformation = glGetUniformLocation(shader_program, "NormalVectorTransformation");
    SL_ModelViewPerspectiveTransformation
        = glGetUniformLocation(shader_program, "ModelViewPerspectiveTransformation");
    SL_AmbientIntensity = glGetUniformLocation(shader_program, "AmbientIntensity");
    SL_LightIntensity = glGetUniformLocation(shader_program, "LightIntensity");
    SL_LightPosition = glGetUniformLocation(shader_program, "LightPosition");
    SL_EyeDirection = glGetUniformLocation(shader_program, "EyeDirection");
}
//------------------------------------------------------------------------------
//
// display() should be called whenever the canvas needs to be refreshed. Here it
// redraws the content of the Figs vector,

void display(void) {
   glClearColor(0.25,0.25,0.25,1); // gray
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   glEnable(GL_DEPTH_TEST);

   glm::vec3 eye = glm::vec3(
         static_cast<GLfloat>(Rho*std::cos(Phi)*std::sin(Theta)),
         static_cast<GLfloat>(Rho*std::sin(Phi)*std::sin(Theta)),
         static_cast<GLfloat>(Rho*std::cos(Theta)));
   glm::vec3 ctr = glm::vec3(0.0f, 0.0f, 0.0f);
   glm::vec3 up  = glm::vec3(0.0f, 0.0f, 1.0f);
   glm::mat4 vmtx = glm::lookAt(eye, ctr, up);
   glm::mat4 pmtx = glm::perspective(glm::radians(50.0f), CANVAS.x/CANVAS.y, 0.1f, 15.0f);

   glm::vec3 eyeDirection = glm::normalize(eye);
   glUniform3fv(SL_EyeDirection, 1, &eyeDirection[0]);
   glUniform3fv(SL_AmbientIntensity, 1, &TheAmbientIntensity[0]);
   glUniform3fv(SL_LightIntensity, 1, &TheLightIntensity[0]);

   glm::vec3 transformedLightPosition = glm::vec3(vmtx * glm::vec4(TheLightPosition, 1.0f));
   glUniform3fv(SL_LightPosition, 1, &transformedLightPosition[0]);

   // Render Spheres
   for (std::vector<Sphere>::iterator iter = SphereVector.begin();
    iter != SphereVector.end(); iter++) {
      glm::mat4 modelViewTransformation = vmtx * iter->model_transformation();
      glm::mat3 vectorTransformation = glm::mat3(vmtx) * iter->vector_transformation();
      glm::mat4 modelViewPerspectiveTransformation  =  pmtx * modelViewTransformation;

      glUniformMatrix4fv(SL_ModelViewTransformation, 1, GL_FALSE, &modelViewTransformation[0][0]);
      glUniformMatrix3fv(SL_NormalVectorTransformation, 1, GL_FALSE, &vectorTransformation[0][0]);
      glUniformMatrix4fv(SL_ModelViewPerspectiveTransformation,
                         1, GL_FALSE, &modelViewPerspectiveTransformation[0][0]);

      iter->draw_elements();
   }


   // Render Cylinders
   for (std::vector<Cylinder>::iterator iter = CylinderVector.begin();
           iter != CylinderVector.end(); iter++) {
      glm::mat4 modelViewTransformation = vmtx * iter->model_transformation();
      glm::mat3 vectorTransformation = glm::mat3(vmtx) * iter->vector_transformation();
      glm::mat4 modelViewPerspectiveTransformation  =  pmtx * modelViewTransformation;

      glUniformMatrix4fv(SL_ModelViewTransformation, 1, GL_FALSE, &modelViewTransformation[0][0]);
      glUniformMatrix3fv(SL_NormalVectorTransformation, 1, GL_FALSE, &vectorTransformation[0][0]);
      glUniformMatrix4fv(SL_ModelViewPerspectiveTransformation,
                         1, GL_FALSE, &modelViewPerspectiveTransformation[0][0]);

      iter->draw_elements();
   }

   // Render Cubes
   for (std::vector<Cube>::iterator iter = CubeVector.begin();
           iter != CubeVector.end(); iter++) {
      glm::mat4 modelViewTransformation = vmtx * iter->model_transformation();
      glm::mat3 vectorTransformation = glm::mat3(vmtx) * iter->vector_transformation();
      glm::mat4 modelViewPerspectiveTransformation  =  pmtx * modelViewTransformation;

      glUniformMatrix4fv(SL_ModelViewTransformation, 1, GL_FALSE, &modelViewTransformation[0][0]);
      glUniformMatrix3fv(SL_NormalVectorTransformation, 1, GL_FALSE, &vectorTransformation[0][0]);
      glUniformMatrix4fv(SL_ModelViewPerspectiveTransformation,
                         1, GL_FALSE, &modelViewPerspectiveTransformation[0][0]);

      iter->draw_elements();
   }
   glfwSwapBuffers(gWindow);
}

void keyboard(GLFWwindow* window, int keyCode, int scanCode, int action, int modifiers) {
   switch (keyCode) {
      case GLFW_KEY_E: // east
         if (action == GLFW_PRESS) {
            if (modifiers == 0x0000) {
               Phi += M_PI/90.0f;
            } else {
               Phi += M_PI/9.0f;
            }
            std::cout << "Phi = " << Phi << std::endl;
         }
         break;
      case GLFW_KEY_H: // home
         if (action == GLFW_PRESS && modifiers == 0x0000) {
            Theta = M_PI/2.0f;
            Phi   = 0.0f;
            Rho   = 1.0f;
            std::cout << "Setting (Rho, Theta, Phi) = ("
               << Rho << ", " << Theta << ", " << Phi << ")" << std::endl;
         }
         break;
      case GLFW_KEY_N: // north
         if (action == GLFW_PRESS) {
            if (modifiers == 0x0000) {
               Theta -= M_PI/90.0f;
            } else {
               Theta -= M_PI/9.0f;
            }
            Theta = std::max(M_PI/180.0f, Theta);
            std::cout << "Theta = " << Theta << std::endl;
         }
         break;
      case GLFW_KEY_P: // print
         if (action == GLFW_PRESS && modifiers == 0x0000) {
            std::cout << "Pressed a lower-case p, scanCode = " << scanCode << std::endl;
            exportWindowAsPNG(window, std::string("caravaggio"));
         }
         break;
      case GLFW_KEY_Q: // quit
         if (action == GLFW_PRESS && modifiers == 0x0000) {
            std::cout << "Pressed a lower-case q, scanCode = " << scanCode << std::endl;
            glfwSetWindowShouldClose(window, GL_TRUE);
         }
         break;
      case GLFW_KEY_R:  // rho
         if (action == GLFW_PRESS) {
            if (modifiers == 0x0000) {
               Rho += 0.2f;
            } else {
               Rho -= 0.2f;
            }
            Rho = std::max(0.1, std::min(10.0, Rho));
            std::cout << "Rho = " << Rho << std::endl;
         }
         break;
      case GLFW_KEY_S:  // south
         if (action == GLFW_PRESS) {
            if (modifiers == 0x0000) {
               Theta += M_PI/90.0f;
            } else {
               Theta += M_PI/9.0f;
            }
            Theta = std::min(M_PI*89.0f/90.0f, Theta);
            std::cout << "Theta = " << Theta << std::endl;
         }
         break;
      case GLFW_KEY_W:  // west
         if (action == GLFW_PRESS) {
            if (modifiers == 0x0000) {
               Phi -= M_PI/90.0f;
            } else {
               Phi -= M_PI/9.0f;
            }
            std::cout << "Phi = " << Phi << std::endl;
         }
         break;
   }
   return;
}

//------------------------------------------------------------------------------
//
// error_callback is used by GLFW.

void GLFW_error_callback(int errorCode, const char* msg) {
   throw std::runtime_error(msg);
}

//------------------------------------------------------------------------------
//
// free image error callback
void fi_error_callback(FREE_IMAGE_FORMAT fif, const char* msg) {
   if (fif != FIF_UNKNOWN) {
      std:: cerr << FreeImage_GetFormatFromFIF(fif) << " format." << std:: endl;
   }
   throw std::runtime_error(msg);
}

int main(int argc, char** argv) {

   // initialize GLFW
   glfwSetErrorCallback(GLFW_error_callback);
   if (!glfwInit())
      throw std::runtime_error("glfwInit failed!");

// Create the main window
glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);
glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);

int glfw_major;
int glfw_minor;
int glfw_rev;
glfwGetVersion(&glfw_major, &glfw_minor, &glfw_rev);
std::cout << "GLFW version: " << glfw_major << "."
   << glfw_minor << "." << glfw_rev << std::endl;

gWindow = glfwCreateWindow((int) CANVAS.x, (int) CANVAS.y, argv[0], NULL, NULL);
if (! gWindow)
   throw std::runtime_error("Can't create a glfw window!");

 glfwMakeContextCurrent(gWindow);

glfwSetKeyCallback(gWindow, keyboard);
glewExperimental = GL_TRUE;  // Prevents a segmentation fault on Mac OSX
if (glewInit() != GLEW_OK)
   throw std::runtime_error("Can't initialize glewInit!");

std::cout << "OpenGL version: "  << glGetString(GL_VERSION) << std::endl;
std::cout << "GLSL version: "    << glGetString(GL_SHADING_LANGUAGE_VERSION) << std::endl;
std::cout << "Vendor: "          << glGetString(GL_VENDOR) << std::endl;
std::cout << "Graphics engine: " << glGetString(GL_RENDERER) << std::endl;

if (! GLEW_VERSION_3_2)
   throw std::runtime_error("OpenGL 3.2 is not supported!");

// Initializing FreeImage:
FreeImage_Initialise(TRUE);                   // only load local plugins.
FreeImage_SetOutputMessage(fi_error_callback);

// Let's see the version of FreeImage:
std::cout << "FreeImage version = " << FreeImage_GetVersion() << std::endl;

init(); // Initialize the model.

int update_count = 0;
while(! glfwWindowShouldClose(gWindow)) {
   update_count++;
   display();
   glfwWaitEvents();     // or, replace with glfwPollEvents();
}

   FreeImage_DeInitialise();
   glfwTerminate();
   std::cout << argv[0] << " gracefully exits after "
      << update_count << " window updates." << std::endl;
   return 0; // Can be safely omitted, but the application will still return 0.
}

// end of caravaggio.cpp
